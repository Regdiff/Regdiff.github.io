其实对于同样一个目标。我们会有不同的抽象表现，而而另外一个比较有趣的东西就说其实不同的抽象表现本身呢，他们虽然在描述同一个目标，其实他们的细细节也是不一样的

机器学习编译的本质在于张量函数之间的转换

所以说对于大部分机器学习编译的过程，其实都是在我们的这个张量函数之间在做各种各样的变化，并且就是对于各种各样的变化，我们可能会包含不同层次的抽象，





主要就是会包含四大形式，就是计算图。其实我们刚才给的这个例子里面比较比较直接的，它就是这张图就计算图的抽象啊，这样程序的抽象啊，算子库和运行时的抽象，以及最后我们硬件里面它会有硬件指令相关的可能的抽象呃







在Python中，`@T.prim_func` 是一个装饰器 (decorator)。装饰器是Python的一种语法糖，允许你在定义函数或方法时通过在其前面加上一个装饰器来扩展或修改其行为。具体来说，`@T.prim_func` 装饰器通常用在定义 TVM 中的原始函数（primitive function）时。

为了更好地理解这个语句，让我们分解一下：

1. **装饰器 (Decorator)**：
   - 装饰器是用于修改函数或方法的行为的特殊函数。它们通常使用 `@` 符号来应用。
   - 装饰器在函数定义之前使用，并接受一个函数作为参数，然后返回一个新的函数或修改后的函数。
2. **`T.prim_func`**:
   - 这是一个特定的装饰器，位于 `T` 的命名空间中（这里 `T` 是 `from tm.script import tir as T` 中导入的）。
   - 在 TVM（Tensor Virtual Machine）项目中，`prim_func` 用于定义原始计算函数，这些函数通常是用于描述高性能计算任务的低级别函数。
3. **`@T.prim_func`**:
   - 当你在一个函数前面使用 `@T.prim_func` 时，你是在告诉 Python，这个函数应该通过 `T.prim_func` 装饰器进行处理。
   - 这个处理可能会包括特定的验证、转换或优化，这取决于装饰器的实现。

以下是一个简单的例子，说明 `@T.prim_func` 是如何使用的：

```
python复制代码from tvm.script import tir as T

@T.prim_func
def my_function(a: T.handle, b: T.handle, c: T.handle) -> None:
    A = T.match_buffer(a, (1024,))
    B = T.match_buffer(b, (1024,))
    C = T.match_buffer(c, (1024,))
    
    for i in range(1024):
        C[i] = A[i] + B[i]
```

在这个例子中：

- `@T.prim_func` 装饰器应用于 `my_function`。
- `my_function` 被定义为一个原始函数，用于计算两个向量的和。

总结来说，`@T.prim_func` 是一个装饰器，它标记并处理一个函数，使其符合 TVM 中原始函数的要求。通过这种方式，TVM 能够识别和优化该函数以进行高性能计算。